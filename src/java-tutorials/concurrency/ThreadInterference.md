# Интерференция потоков  

[Сурс](https://docs.oracle.com/javase/tutorial/essential/concurrency/interfere.html)  

Определим простой класс Counter:  

    class Counter {
        private int c = 0;

        public void increment() {
            c++;
        }

        public void decrement() {
            c--;
        }

        public int value() {
            return c;
        }
    }

Счетчик разработан таким образом, что каждый вызов инкремента будет добавлять к значению переменной c единицу, а вызов декремента - вычитать её. Однако если несколько потоков взаимодействуют с инстансом Counter, интерференция потоков может привести к неожиданным результатам выполнения этих методов.  

Интерференция происходит когда две операции, выполняемые в разных потоках, работают с одними и теми же данными по очереди. Это означает, что эти две операции дискретные и их шаги могут накладываться друг на друга.  

На первый взгляд такое может показаться невозможным, так как обе операции, влияющие на c - одиночные простые операции. Однако даже простые выражения могут быть превращены виртуальной машиной в последовательность шагов. Мы не будем детально рассматривать разложение операции на шаги виртуальной машиной, достаточно понимать. что одно выражение c++ может быть декомпозировано следующим образом:

- Получить текущее значение c.  
- Увеличить полученное значение на 1.  
- Сохранить увеличенное значение в переменную c.  

Выражение c-- можно декомпозировать аналогичным способом, но на втором шаге будет не увеличение значения на единицу, а уменьшение.  

Предположим, поток A вызывает инкрементирующую операцию в то же время, как поток B вызывает декрементирующую. Если начальное значение c - 0, то наложившиеся друг на друга операции в потоках A и B могут вызвать следующую последовательность действий:  

    Поток A: Получает результат c.
    Поток B: Получает результат c.
    Поток A: Увеличивает полученное значение; результат 1.
    Поток B: Уменьшает полученное значение; результат -1.
    Поток A: Сохраняет результат в c; c равна 1.
    Поток B: Сохраняет результат в c; c теперь -1.

Результат работы потока A утерян, т.к. перезаписан потоком B. Приведенный вариант чередований - лишь один из вариантов. Мы можем также получить в итоге результат потока A или получить соответствующий нашим ожиданиям результат "без ошибки" - 0. Ошибки интерференции потоков трудно обнаружить и исправить, так как они непредсказуемы.  
