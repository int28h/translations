# Создание и запуск потока  

[Сурс](https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html)  

Приложение, умеющее создавать инстанс Thread, должно также уметь запускать этот поток. Есть два способа сделать это:  

+ Предоставлять объект, имплементирующий Runnable.  
Интерфейс Runnable определяет единственный метод — run() — содержащий код, который будет выполняться в отдельном потоке. Runnable-объект передается в конструктор Thread:  

		public class HelloRunnable implements Runnable {

			public void run() {
				System.out.println("Hello from a thread!");
			}

			public static void main(String args[]) {
				(new Thread(new HelloRunnable())).start();
			}
		}

+ Предоставлять экземпляр класса, являющегося наследником Thread.  
Класс Thread сам по себе реализует интерфейс Runnable, однако его run() ничего не делает. Приложение может иметь класс-наследник Thread, который будет предоставлять собственную имплементацию run():  

		public class HelloThread extends Thread {

			public void run() {
				System.out.println("Hello from a thread!");
			}

			public static void main(String args[]) {
				(new HelloThread()).start();
			}
		}

Обратите внимание, что в обоих случаях для старта нового потока вызывается Thread.start().  

Какой из этих вариантов следует использовать? Первый, в котором используется Runnable-объект, более общий, потому что такой объект может наследовать какой-либо другой класс — не Thread. Второй подход легче использовать в простых приложениях, но он имеет ограничение — класс выполняемой в потоке задачи может являться только потомком Thread. Данный урок фокусируется на первом способе, который отделяет Runnable-задачу от объекта Thread, выполняющего эту задачу. Этот подход не только более гибкий, но и применим для высокоуровнего управления потоками, которое будет рассматриваться позднее.

Класс Thread определяет методы, полезные для управления потоками. К ним относятся статические методы, которые предоставляют информацию о потоке, вызвавшем метод, или влияют на его состояние. Остальные методы вызываются из других потоков, участвующих в управлении потоком и объектом Thread. Мы рассмотрим некоторые из этих методов в следующих разделах.  
