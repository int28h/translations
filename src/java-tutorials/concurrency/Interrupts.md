# Прерывания  
  
[Сурс](https://docs.oracle.com/javase/tutorial/essential/concurrency/interrupt.html)  
  
Прерывание — это указание для потока прекратить выполнение текущих операций и заняться чем-то иным. Программист решает, как именно поток отреагирует на прерывание, но как правило поток просто завершает свою работу. Такое использование прерываний подчеркивается в данном уроке.  
  
Поток вызывает прерывание с помощью вызова interrupt() для потока (т.е. для инстанса Thread или инстанса его дочернего класса), который нужно прервать. Для корректной работы прерываемый поток должен поддерживать механизм собственного прерывания.  

## Поддержка прерывания  
  
Как поток поддерживает собственное прерывание? Это зависит от того, чем он занят в текущий момент. Если в потоке часто вызваются методы, которые выбрасывают InterruptedException, то происходит возврат из метода run() после перехвата такого эксепшена. Например, предположим, что центральный цикл по сообщениям в примере SleepMessages находится в методе run() Runnable-объекта. Тогда он может быть изменен для поддержки прерываний следующим образом:  
  
	for (int i = 0; i < importantInfo.length; i++) {
		// Pause for 4 seconds
		try {
			Thread.sleep(4000);
		} catch (InterruptedException e) {
			// We've been interrupted: no more messages.
			return;
		}
		// Print a message
		System.out.println(importantInfo[i]);
	}
  
Многие методы, выбрасывающие InterruptedException — как, например, sleep(...) — при получении прерывания отменяют свою текущую операцию и немедленнно осуществляют возврат.  
  
Что если поток долгое время не вызывает метод, генерирующий InterruptedException? Тогда он должен периодически вызывать Thread.interrupted(), который вернет true, если было получено прерывание. Например:  
  
	for (int i = 0; i < inputs.length; i++) {
		heavyCrunch(inputs[i]);
		if (Thread.interrupted()) {
			// We've been interrupted: no more crunching.
			return;
		}
	}
  
В этом простом примере код проверяет наличие прерывания и, если оно получено, выполнение метода завершается. В более сложных приложениях в таком случае рациональнее будет выбросить InterruptedException:  
  
	if (Thread.interrupted()) {
		throw new InterruptedException();
	}
  
Это позволяет обернуть код для обработки прерывания в catch(...){...}.   
  
## Флаг статуса прерывания  
  
Механизм прерывания реализуется с использование внутреннего флага, известного как статус прерывания (the interrupt status). Вызов Thread.interrupt() устанавливает этот флаг. Когда поток проверяет наличие прерывания путём вызова *статического* метода *Thread.interrupted()*, статус прерывания *очищается*. *Нестатический* метод *isInterrupted()* используется одним потоком для проверки состояния другого потока и *не изменяет* статус прерывания.  
  
По соглашению, любой метод, который завершается выбросом InterruptedException, при этом очищает состояние прерывания. Однако всегда возможно, что статус прерывания будет незамедлительно снова установлен другим потоком, вызывающим прерывание.  
  